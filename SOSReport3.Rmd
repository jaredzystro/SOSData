---
title: State Of Organic Seed <br>Producer Survey
resource_files:
- www/cropped-logo-header.png
runtime: shiny
output:
  html_document:
    css: https://seedalliance.org/wp-content/themes/showcase-pro/style.css?ver=1.0.2
    highlight: null
    number_sections: no
    theme: spacelab
    toc: yes
    toc_float: yes
---

```{css, echo=FALSE}
h1{font-size:18px;}
h2{font-size:16px;}
.title {
  background-color: #2d677f;
  color:#ffffff;
  padding-right: 200px;
  padding-top: 10px;
  padding-left: 10px;
  padding-bottom: 10px;
}

.box {
  padding: 1em;
  background: white;
  border: 2px solid black;
  border-radius: 10px;
}

```

```{r message=FALSE, warning=FALSE, include=FALSE}

### Load
rm(list=ls())

install_or_load_pack <- function(pack){
  # from https://nhsrcommunity.com/blog/a-simple-function-to-install-and-load-packages-in-r/
  create.pkg <- pack[!(pack %in% installed.packages()[, "Package"])]
  if (length(create.pkg))
  {
    install.packages(create.pkg, dependencies = TRUE, repos = "http://cran.us.r-project.org")
  }
  sapply(pack, require, character.only = TRUE)
}


### Initialize packages and read data----

# Comment out package installation prior to deploying
#packages <- c("survey","ggplot2","shiny","dplyr","srvyr", "sf", "spData")
#install_or_load_pack(packages)

library(survey)
library(ggplot2)
library(shiny)
library(dplyr)
library(srvyr)
library(sf)
library(spData)
library(stringr)
library(maps)
library(ggiraph)


zipcode <- read.csv("zipcode.csv", as.is = TRUE)
data <- read.csv("NORA19_merged.csv")
key <- read.csv("question_labels.csv")
data2015 <- read.csv("2015SurveyData.csv", skip=2, header=TRUE)
data2010 <- read.csv("2010SurveyData.csv", skip=2, header=TRUE)

# Constant to set plot heights in pixels
# Temporary fix until I can get a better dynamic plot sizing plan in place
PLOTHEIGHT <- 600

### Section for question data wrangling ----

### Q01A is year farm first certified
# These lines tidy it up and split into bins for plotting
data$YearsCertified <- as.numeric(data$Q01A)
# Convert to years certified
data$YearsCertified <- 2020 - data$YearsCertified
# Convert to bins
data$YearsCertified_bin <- cut(data$YearsCertified, breaks=c(0,1,3,6,10,15,20,30,1000), labels=c("<1","1 - 3","4 - 6","7 - 10", "11 - 15", "16 - 20", "21 - 30", "30+"))
data$YearsCertified_bin <- factor(data$YearsCertified_bin)

### 2015 tidy up
data2015$YearsCertified <- as.numeric(data2015$YearsCertified)
# Convert to bins
data2015$YearsCertified_bin <- cut(data2015$YearsCertified, breaks=c(0,1,3,6,10,15,20,30,1000), labels=c("<1","1 - 3","4 - 6","7 - 10", "11 - 15", "16 - 20", "21 - 30", "30+"))
data2015$YearsCertified_bin <- factor(data2015$YearsCertified_bin)

### Q05 is whether they had any veg acres
# Change non-responses to NA
data$GrowVegis <- ifelse (data$Q05 == "No answer" | data$Q05 == "partial complete" | data$Q05 == "skipped due to branching", NA, data$Q05)
# Convert from text to numeric -- 100 for veg, 0 for not. Probably a better way to do this...
data$GrowVegis <- ifelse (data$GrowVegis == "Some Annual Vegetable Crop Acres" | data$GrowVegis == "Some annual vegetable crop acres:", 100, 0) %>%
              as.numeric()

# Do the same for 2015 veg growing question
# Convert from text to numeric -- 100 for veg, 0 for not. Probably a better way to do this...
data2015$GrowVegis <- ifelse (data2015$GrowVegis == "Yes.", 100, 0) %>%
              as.numeric()

### Q05_2_o is vegetable acreage
# These lines split it into bins for plotting
# Remove missing data keys
data$VegiAcreage <- ifelse(!is.na(data$Q05_2_o) & (data$Q05_2_o == -1 | data$Q05_2_o == -2 | data$Q05_2_o == -3), NA, data$Q05_2_o)
data$VegiAcreage <- as.numeric(data$VegiAcreage)
# Convert to bins
data$VegiAcreage <- cut(data$VegiAcreage, breaks=c(0,3,10,50,80,160,480,1000000), labels=c("0.01 - 3","3.01 - 10","10.01 - 50","50.01 - 80", "80.01 - 160", "160.01 - 480", ">480"))
data$VegiAcreage <- factor(data$VegiAcreage)

# Do the same for the 2015 VegiAcreage
# Convert to bins
data2015$VegiAcreage <- cut(data2015$VegiAcreage, breaks=c(0,3,10,50,80,160,480,1000000), labels=c("0.01 - 3","3.01 - 10","10.01 - 50","50.01 - 80", "80.01 - 160", "160.01 - 480", ">480"))
data2015$VegiAcreage <- factor(data2015$VegiAcreage)


### Q06 is whether they had any cover crop acres
# Change non-responses to NA
data$Q06 <- ifelse (data$Q06 == "No answer" | data$Q06 == "partial complete" | data$Q06 == "skipped due to branching", NA, data$Q06)
# Convert from text to numeric -- 100 for veg, 0 for not. Probably a better way to do this...
data$Q06 <- ifelse (data$Q06 == "Some cover crop/green pasture acres" | data$Q06 == "Some Cover Crops/Green Pasture Acres", 100, 0) %>%
              as.numeric()

### Q06_2_o is cover crop acreage
# These lines split it into bins for plotting
# Remove missing data keys
data$Q06_2_o <- ifelse(!is.na(data$Q06_2_o) & (data$Q06_2_o == -1 | data$Q06_2_o == -2 | data$Q06_2_o == -3), NA, data$Q06_2_o)
data$Q06_2_o <- as.numeric(data$Q06_2_o)
# Convert to bins
data$Q06_2_o_bin <- cut(data$Q06_2_o, breaks=c(0,3,10,50,80,160,480,1000000), labels=c("0.01 - 3","3.01 - 10","10.01 - 50","50.01 - 80", "80.01 - 160", "160.01 - 480", ">480"))
data$Q06_2_o_bin <- factor(data$Q06_2_o_bin)


### Q07 is whether they had any field crop acres
# Change non-responses to NA
data$Q07 <- ifelse (data$Q07 == "No answer" | data$Q07 == "partial complete" | data$Q07 == "skipped due to branching", NA, data$Q07)
# Convert from text to numeric -- 100 for veg, 0 for not. Probably a better way to do this...
data$Q07 <- ifelse (data$Q07 == "Some field crop acres" | data$Q07 == "Some field crop acres:", 100, 0) %>% as.numeric()

### Q07_2_o is field crop acreage
# These lines split it into bins for plotting
# Remove missing data keys
data$Q07_2_o <- ifelse(!is.na(data$Q07_2_o) & (data$Q07_2_o == -1 | data$Q07_2_o == -2 | data$Q07_2_o == -3), NA, data$Q07_2_o)
data$Q07_2_o <- as.numeric(data$Q07_2_o)
# Convert to bins
data$Q07_2_o_bin <- cut(data$Q07_2_o, breaks=c(0,3,10,50,80,160,480,1000000), labels=c("0.01 - 3","3.01 - 10","10.01 - 50","50.01 - 80", "80.01 - 160", "160.01 - 480", ">480"))
data$Q07_2_o_bin <- factor(data$Q07_2_o_bin)

# Converting responses to numeric form
data$Q05aA <- as.numeric(data$Q05aA)
data$Q06aA <- as.numeric(data$Q06aA)
data$Q07aA <- as.numeric(data$Q07aA)

# Q26B is what percentage of seed they got from seed they saved
# Making a column to turn this into yes/no with 100 = yes, 0 = no
data$Q26B_yes <- as.numeric(data$Q26B)
data$Q26B_yes <- ifelse(!is.na(data$Q26B_yes) & data$Q26B_yes>0, 100, 0)

# Q34 is Are you interested in producing organic seed for commercial use at some point in the future?
# Change non-responses to NA
# Order factors
data$Q34 <- ifelse (data$Q34 == "No answer" | data$Q34 == "partial complete" | data$Q34 == "skipped due to branching", NA, data$Q34)
data$Q34 <- factor(data$Q34, levels = c("Not interested", "Somewhat interested", "Interested", "Very interested"))

### Q29A - Q29H are factors in producers' decision NOT to purchase organic seed
# Change non-responses to NA
# Order factors
CleanUpSeedFactorQs <- function (question) {
  question <- ifelse (question == "No answer" | question == "partial complete" | question == "skipped due to branching", NA, question)
  question <- factor(question, levels = c("Not a factor", "Slight factor", "Moderate factor", "Significant factor"))
  return (question)
}
# 29A Lack of seed treatments, such as pelleting or priming
data$Q29A <- CleanUpSeedFactorQs(data$Q29A)
# 29B Processor (buyer) requires or supplies varieties that are not available organically
data$Q29B <- CleanUpSeedFactorQs(data$Q29B)
# 29C Insufficient quantity of seed
data$Q29C <- CleanUpSeedFactorQs(data$Q29C)
# 29D Save my own seed
data$Q29D <- CleanUpSeedFactorQs(data$Q29D)
# 29E Distrust of organic seed quality
data$Q29E <- CleanUpSeedFactorQs(data$Q29E)
# 29F Price
data$Q29F <- CleanUpSeedFactorQs(data$Q29F)
# 29G Specific variety not available as organic seed
data$Q29G <- CleanUpSeedFactorQs(data$Q29G)
# 29H Lack of desirable genetic traits
data$Q29H <- CleanUpSeedFactorQs(data$Q29H)

#Convert Respondent ID to factor
data$RespID <- factor(data$RespID)

### Create additional global variables ----

# Add column of state abbreviations to data based on zipcode
getzipcode <- zipcode$state
names(getzipcode) <- zipcode$zip
data$state <- unname(getzipcode[as.character(data[,"Q04A"])])
data2015$state <- unname(getzipcode[as.character(data2015[,"Zip1"])])

# Create weight and survey object for survey based on current total population of organic producers (14,217 as of 2020)
tot_pop <- 14217
data$weight <- length(data$RespID) / tot_pop

mydesign <- 
  svydesign( 
    ids = ~1 , 
    data = data , 
    weights = ~weight
  )

# Create weight and survey object for 2015 survey based on 2014 total population of organic producers (14,093)
tot_pop2015 <- 14093
data2015$weight <- length(data2015$RespondentID) / tot_pop

mydesign2015 <- 
  svydesign( 
    ids = ~1 , 
    data = data2015 , 
    weights = ~weight
  )

# Get sp type shape data for states
# Add column of abbreviations
data("us_states")
us_states$state <- state.abb[match(us_states$NAME,state.name)]

# Dropping HI and AK for now because it is so far from everything
# Will need a way to incorperate eventually
rownames(zipcode) <- zipcode$zip
zipcode$zip <- as.character(zipcode$zip)
data$zip <- data$Q04A
zips <- left_join(data[,c("Q04A","zip")], zipcode, by = "zip")
zips <- zips[zips$state != "HI",]
zips <- zips[zips$state != "AK",]

data2015$zip <- as.character(data2015$Zip1)
zips2015 <- left_join(data2015[,c("Zip1","zip")], zipcode, by = "zip")
zips2015 <- zips2015[zips2015$state != "HI",]
zips2015 <- zips2015[zips2015$state != "AK",]


# Get state data for gradient maps and convert to upper case
# Add column of abbreviations
states_map <- map_data("state")
states_map$region <- str_to_title(states_map$region)
states_map$state <- state.abb[match(states_map$region,state.name)]

### Scratch code -- mapping code experiments
# states <- ne_states(country = "united states of america", returnclass = "sf")

# "spDataLarge" , "rnaturalearth", "rnaturalearthdata"
#install_or_load_pack(packages)
# install.packages("rnaturalearthhires", repos = "http://packages.ropensci.org", type = "source")

# ggplot(zips,aes(longitude,latitude)) +
#   geom_polygon(data=us,aes(x=long,y=lat,group=group),color='gray',fill=NA,alpha=.35)

# ggplot(data = us_states) +
#     geom_sf(colour = "black", fill = "white") +
#     geom_point(data = zips, mapping = aes(x = longitude, y = latitude), colour = "blue", shape=21) +
#   coord_sf(crs = st_crs(us_states), datum = NA) +
#   theme(
#     panel.grid = element_blank(),
#     line = element_blank(),
#     rect = element_blank(),
#     text = element_blank(),
#     plot.background = element_rect(fill = "white"))
# 
# ##
# 
# input<-list()
# input$state <- "WI"
# 
# if (input$state!="All") {
#   
#   full_name <- state.name[match(input$state,state.abb)]
#   filtered_states <- us_states[us_states$NAME==full_name,]
#   filtered_zips <- zips[zips$state==input$state,]
# } else {
#   filtered_states <- us_states
#   filtered_zips <- zips
# }
# 
# ggplot(data = filtered_states) +
#     geom_sf(colour = "black", fill = "white") +
#     geom_point(data = filtered_zips, mapping = aes(x = longitude, y = latitude), colour = "blue", shape=21) +
#   coord_sf(crs = st_crs(filtered_states), datum = NA) +
#   theme(
#     panel.grid = element_blank(),
#     line = element_blank(),
#     rect = element_blank(),
#     text = element_blank(),
#     plot.background = element_rect(fill = "white"))
# ##
# 
# state.name[match("NY",state.abb)]
# 
# CA <- us_states[us_states$NAME=="California",]
# CA_zip <- zips[zips$state=="CA",]
# 
# ggplot(data = CA) +
#     geom_sf(colour = "black", fill = "white") +
#     geom_point(data = CA_zip, mapping = aes(x = longitude, y = latitude), colour = "blue", shape=21) +
#   coord_sf(crs = st_crs(CA), datum = NA) +
#   theme(
#     panel.grid = element_blank(),
#     line = element_blank(),
#     rect = element_blank(),
#     text = element_blank(),
#     plot.background = element_rect(fill = "white"))


# install.packages("maps")
# library(maps)
# 
# rownames(zipcode) <- zipcode$zip
# zips<-zipcode[data$Q04A, 1:6]
# 
# us<-map_data('state')
# 
# ggplot(zips,aes(longitude,latitude)) +
#   geom_polygon(data=us,aes(x=long,y=lat,group=group),color='gray',fill=NA,alpha=.35)
# 
# map <- get_openstreetmap(bbox = c("left" = -125, "bottom" = 25.75, "right" = -67, "top" = 49))
# p <- ggmap(map)+geom_point(aes(x=longitude, y=latitude), data=zips, alpha=.5)
# print(p)
# ci <- confint(svyciprop(~vegpercent, design=subset(mydesign,state=="CA"), method="logit", na.rm=TRUE))
# 
# mean <- svymean(~vegpercent, design=subset(mydesign,state=="CA"), method="logit", na.rm=TRUE)
# 
# 
# svyby(~Q07AA, list(data$state=="IN"), mydesign, svymean,vartype="ci")

#input$state <- c("CA","OR")

### Function to generate map based on producer zip and selected states ----
MapPlot <- function (input) {
  
# Avoid red error message when nothing is selected for input$state by validating
  validate(need(input$state, 'Please choose a state.'))
  
  if (input$state=="All") {
    
    filtered_states <- us_states
    filtered_zips <- zips
    filtered_zips2015 <- zips2015
    
# Filter zip code points and state shapes based on input$state
  } else {
    
 #   full_name <- state.name[match(input$state,state.abb)]
    filtered_states <- us_states[us_states$state %in% input$state,]
    filtered_zips <- zips[zips$state %in% input$state,]
    filtered_zips2015 <- zips2015[zips2015$state %in% input$state,]
  }
  
# ggplot of state shapes (goem_sf) and zip codes (goem_point)
# shape=21 is open circle
# coords_sf is set to get rid of longitude and latitude notations
# theme is set to get rid of lines
p <-  ggplot(data = filtered_states) +
    geom_sf(colour = "black", fill = "white") +
    coord_sf(crs = st_crs(filtered_states), datum = NA) +
    theme(
      panel.grid = element_blank(),
      line = element_blank(),
      rect = element_blank(),
      text = element_blank(),
      plot.background = element_rect(fill = "white"))

  if (input$Y2020) {
  
    p <- p + geom_point(data = filtered_zips, mapping = aes(x = longitude, y = latitude), colour = "#2d677f", shape=21, size=3)
  }

  if (input$Y2015) {
    p <- p +       geom_point(data = filtered_zips2015, mapping = aes(x = longitude, y = latitude), colour = "#da413d", shape=21, size=3)
    }

plot (p)
   
}

### Function to make box plots of question means and errors ----
BoxPlot <- function (input, question, title, xlab, ylab) {
  
# dummy variables for testing
  # input <- list()
  # input$state <- "All"
  # input$Y2015 <- TRUE
  # input$Y2020 <- TRUE
  # input$show_n <- TRUE
  # question <-"GrowVegis"
  
# Avoid red error message when nothing is selected for input$state by validating
  validate(need(input$state, 'Please choose at least one state.'))
  validate(need(input$Y2015 | input$Y2020, 'Please choose at least one year.'))
  validate(need((!is.null(data[[question]]) & input$Y2020) |
                (!is.null(data2015[[question]]) & input$Y2015)
                , 'Data not available for this question for the year(s) selected'))
  
# Empty summary dataframe to add year data to
  survey_summary <- data.frame (
      "year" = character(),
      "question" = integer(),
      "mean" = integer(),
      "CI" = integer(),
      "n" = integer()
    )
  
  # Empty color pallet
  graph_color <- character()
  
  # code for 2020 data
  if (!is.null(data[[question]]) & input$Y2020) {
  
    if (input$state == "All") {
      
      sub2020 <- mydesign
      
    } else {
      
# filter to only survey data for correct states
      sub2020 <- subset(mydesign,state %in% input$state)
      
    }

  # Compile mean, error and total number of responses
    survey_mean2020 <- svymean(as.formula(paste0("~",question)), sub2020, na.rm=TRUE)
    responses <- sub2020$variables[question]
    n2020 <- length(responses[!is.na(responses)])

  # Create new data frame from compiled data for ggplot
    survey_summary2020 <- data.frame (
      "year" = "2020",
      "question" = question,
      "mean" = as.data.frame(survey_mean2020)$mean,
      "CI" = as.data.frame(survey_mean2020)[[question]]*1.96,
      "n" = n2020
    )
  survey_summary2020$summary_labels <- paste("n = ",survey_summary2020$n,sep="")
  
# Add to overall summary dataframe
  survey_summary <- merge(survey_summary,survey_summary2020, all=TRUE)
  
  # Add color to graph_color
  graph_color <- c(graph_color,"#2d677f")
  
  }

  # code for 2015 data
  if (!is.null(data2015[[question]]) & input$Y2015) {
   
    if (input$state == "All") {
 
        sub2015 <- mydesign2015 
  
    } else {
      
# filter to only survey data for correct states
        sub2015 <- subset(mydesign2015,state %in% input$state) 
        
    }

# Compile mean, error and total number of responses
      survey_mean2015 <- svymean(as.formula(paste0("~",question)), sub2015, na.rm=TRUE)
      responses2015 <- sub2015$variables[question]
      n2015 <- length(responses2015[!is.na(responses2015)])

  # Create new data frame from compiled data for ggplot
     survey_summary2015 <- data.frame (
      "year" = "2015",
      "question" = question,
      "mean" = as.data.frame(survey_mean2015)$mean,
      "CI" = as.data.frame(survey_mean2015)[[question]]*1.96,
      "n" = n2015
    )
    survey_summary2015$summary_labels <- paste("n = ",survey_summary2015$n,sep="")
     
    # Add to overall summary dataframe
      survey_summary <- merge(survey_summary,survey_summary2015, all=TRUE)
      
    # Add color to graph_color
      graph_color <- c(graph_color, "#da413d")
  }
  
# ggplot plots mean (goem_bar) and error (geom_errorbar)
# Mean and n are added onto bar via the two geom_text calls
# Adds labels for the title, x, and y axis based on inputted variables title, xlab, and ylab
# Currently the y axis is fixed at 1-100, should make that dynamic

  
## Scratch code to automatically wrap titles  
# font_size <- 10
# wrap_width <- ???plotsize?? / (font_size*ggplot2:::.pt)
  
# ggplot(df2, aes_string("V1")) +
# geom_bar() +
# scale_x_discrete(labels = function(x) stringr::str_wrap(x, width = wrap_width))
  
p <- ggplot(survey_summary, aes(x=question, fill = year, y=mean)) +
  geom_bar(stat = "identity", color = "black", width = 0.3, position = position_dodge(width=0.9)) +
  geom_errorbar(alpha = 1, mapping = aes(x = question, ymin = mean-CI, ymax = mean+CI), position = position_dodge(width=0.9),  size=.75, width=.1) +
  scale_fill_manual(values = graph_color) +
  ylim(0,100) +
  geom_text(aes(label=round(mean,1), vjust=2), color="black", size=10, position = position_dodge(width = 0.9)) +
  theme_linedraw(base_size = 30) +
  labs(title = title,
        x = xlab, y = ylab) +
  theme(plot.title = element_text(hjust = 0.5),
          axis.text.x = element_blank())

# Remove legend if only one year
  if (nrow(survey_summary) == 1) {
    p <- p +  theme(legend.position="none")
  }

# Add n if checked
  if (input$show_n) {
    p <- p + geom_text(aes(label=summary_labels, vjust=4), color="black", size=10, position = position_dodge(width = 0.9))
  }

  plot(p)

}
      
### Function to make box plot for responses that can be split into bins ----
BinPlot <- function (input, question, title, xlab, ylab) {
  
# dummy variables for testing
# input <- list()
# input$state <- "All"
# input$Y2015 <- TRUE
# input$Y2020 <- TRUE
# input$show_n <- TRUE
# question <-"VegiAcreage"
  
# Avoid red error message when nothing is selected for input$state by validating
  validate(need(input$state, 'Please choose at least one state.'))
  validate(need(input$Y2015 | input$Y2020, 'Please choose at least one year.'))
  validate(need((!is.null(data[[question]]) & input$Y2020) |
                (!is.null(data2015[[question]]) & input$Y2015)
                  , 'Data not available for this question for the year(s) selected'))
    
# Build empty dataframe to add year summary data to
  out <- data_frame(
    "summary" = integer(),
    "summary_low" = integer(),
    "summary_upp" = integer(),
    "n" = integer(),
    "summary_labels" = character(),
    "year" = character()
  )
  
# Empty color pallet
  graph_color <- character()
  
  # code for 2020 data
  if (!is.null(data[[question]]) & input$Y2020) {
  
  # Remove missing data
    data <- data[!is.na(data[question]),]
    mydesign2020 <- data %>% as_survey_design(id = 1, weight  = weight)
    
    if (input$state == "All") {
        sub2020 <- mydesign2020
      } else {
  # Filter to input states
        sub2020 <- subset(mydesign2020,state %in% input$state)
      }
      
  # Create summary data of means and confidence intervals for bins
    out2020 <- sub2020 %>%
      group_by_at(question) %>%
      summarize(summary = survey_mean(vartype = "ci"), n = unweighted(n())) %>%
      mutate(summary = summary * 100, summary_low = summary_low * 100, summary_upp = summary_upp * 100)
    out2020$summary_labels <- paste("n = ",out2020$n,sep="")
    out2020$year <- "2020"
    
    # merge with overall summary
    out <- merge(out,out2020, all=TRUE)
    
    # Add color to graph_color
    graph_color <- c(graph_color,"#2d677f")
    
  }
  
  # code for 2015 data
  if (!is.null(data2015[[question]]) & input$Y2015) {
  
  # Remove missing data
    data2015 <- data2015[!is.na(data2015[question]),]
    mydesign2015 <- data2015 %>% as_survey_design(id = 1, weight  = weight)
    
    if (input$state == "All") {
        sub2015 <- mydesign2015
      } else {
  # Filter to input states
        sub2015 <- subset(mydesign2015,state %in% input$state)
      }
      
  # Create summary data of means and confidence intervals for bins
    out2015 <- sub2015 %>%
      group_by_at(question) %>%
      summarize(summary = survey_mean(vartype = "ci"), n = unweighted(n())) %>%
      mutate(summary = summary * 100, summary_low = summary_low * 100, summary_upp = summary_upp * 100)
    out2015$summary_labels <- paste("n = ",out2015$n,sep="")
    out2015$year <- "2015"
    out2015$color <- "#da413d"
    
    # merge with overall summary
    out <- merge(out,out2015, all=TRUE)
    
    # Add color to graph_color
    graph_color <- c(graph_color,"#da413d")
    
  }
  
# ggplot of means (geom_bar) and error (geom_errorbar) for bins
  p <- ggplot(data = out, aes_string(x = question, y = "summary",  fill = "year")) +
    geom_bar(stat = "identity", color = "black", width = 0.3, position = position_dodge(width=0.9)) +
    geom_errorbar(alpha = 1, mapping = aes_string(question, ymin = "summary_low", ymax = "summary_upp",  fill = "year"), inherit.aes = FALSE, size=.75, width=.1, position = position_dodge(width=0.9)) +
#    ylim(0,100) +
    theme_linedraw(base_size = 30) +
    labs(title = title,
         x = xlab, y = ylab)  +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(axis.text.x=element_text(angle=45,hjust=1)) +
    scale_fill_manual(values = graph_color)
  
  # Remove legend if only one year
  if (length(levels(as.factor(out$year))) == 1) {
    p <- p +  theme(legend.position="none")
  }
  
  if (input$show_n) {
    p <- p + geom_text(aes(label=summary_labels, vjust=1), color="black", size=10, position = position_dodge(width=0.9))
  }
  
  plot(p)
  
}

## Scratch code for gradient maps
GradientMap <- function (input, question, title, catlab) {

# dummy data for testing
#  input <- list()
#  input$state <- c("AZ","CA","WA","OR","NV")
#  input$state <- c("All")
#  question <- "Q05aA"
#  catlab <- "Percent Vegetable Seed Used"
  
  validate(need(input$state, 'Please choose at least one state.'))
  
  data <- data[!is.na(data[question]),]
  
  if (input$state=="All") {
    
    filtered_state_map <- states_map
    filtered_state_names <- state.name
    filtered_data <- data[,c(question,"state")]
    
# Filter zip code points and state shapes based on input$state
  } else {
    
    filtered_state_map <- states_map[states_map$state %in% input$state,]
    filtered_data <- data[,c(question,"state")]
    filtered_data <- filtered_data[filtered_data$state %in% input$state,]

  }

# Retrieve the states map data and merge with pounds data

data_sum <- filtered_data %>%
  group_by(state) %>%
    summarise(mean = mean(.data[[question]]), n = n())

seed_map <- left_join(filtered_state_map, data_sum, by = "state")

# Create the map

  ggplot(seed_map, aes(long, lat, group = group))+
  geom_polygon(aes(fill = mean), color = "grey50")+
  scale_fill_gradient(low = "#ffffff", high = "#2d677f", na.value = "grey50", name = catlab) +
  coord_sf(crs = st_crs(seed_map), datum = NA) +
  theme_linedraw(base_size = 30) +
  theme(
        panel.grid = element_blank(),
        line = element_blank(),
        rect = element_blank(),
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.title.y = element_blank(),
        axis.title.x = element_blank(),
        plot.title = element_text(hjust = 0.5),
        legend.text =  element_text(size = rel(0.5)),
        plot.background = element_rect(fill = "white")) +
  labs(title = title)

}

## Scratch code for interactive map
  # ggplot() + 
  # geom_polygon_interactive(data = seed_map, color = 'gray50',
  #                                   aes(x = long, y = lat, fill = q_mean, group = group,
  #                                       tooltip = sprintf("%s<br/>%s", q_mean, q_n))) +
#  geom_polygon_interactive(data = world_data, color = 'gray70', size = 0.1,
#                                    aes(x = long, y = lat, fill = Value, group = group, 
#                                        tooltip = sprintf("%s<br/>%s", mean,"% ,n=", n)))
  #geom_polygon_interactive(data = seed_map, aes(fill = q_mean,  tooltip = q_mean), color = "grey50") +
 # scale_fill_gradient(low = "lightblue", high = "darkblue", na.value = "grey50", name = catlab) +
 #  coord_sf(crs = st_crs(seed_map), datum = NA) +
 #  theme_linedraw(base_size = 30) +
 #  theme(
 #        panel.grid = element_blank(),
 #        line = element_blank(),
 #        rect = element_blank(),
 #        axis.text.x = element_blank(), 
 #        axis.text.y = element_blank(),
 #        axis.title.y = element_blank(),
 #        axis.title.x = element_blank(),
 #        plot.title = element_text(hjust = 0.5),
 #        legend.text = element_text(size= 7),
 #        plot.background = element_rect(fill = "white")) +
 #  labs(title = title)


## Scratch code for experimenting with survey summarizing, bin and box plots

#   BinPlot (input = input, question = "Q05_2_o_bin", title = "Acreage", xlab = paste0(input$state,"Organic Acreage"), ylab = "")
  

# input<-list()
# input$state <- "All"
# 
#       p <- BoxPlot (input = input, question = "Q05aA", title = "Percent Vegetable Acreage Planted To Organic Seed", xlab = paste0(input$state," Vegetable Acreage"), ylab = "Percentage")
#       print(p)
      
# survey_mean <- svymean(as.formula(paste0("~",question)), sub, na.rm=TRUE)
# responses <- sub$variables[question]
# n <- length(responses[!is.na(responses)])
      
# survey_summary <- data.frame (
#     "year" = "2020",
#     "question" = question,
#     "mean" = as.data.frame(survey_mean)$mean,
#     "CI" = as.data.frame(survey_mean)[[question]]*1.96,
#     "n" = n
#   )
  
# data <- data[!is.na(data$Q05_2_o_bin),]
#       
# mydesign <- data %>% as_survey_design(id = 1, weight  = weight)
# 
# # summ <- mydesign %>%
# #     group_by(Q05_2_o_bin) %>%
# #     summarize(proportion = survey_mean(proportion = TRUE, vartype = "se", prop_method = "logit"))
# #       
# # print(summ)
# 
# out <- mydesign %>%
#   group_by(Q05_2_o_bin) %>%
#   summarize(summary = survey_mean(vartype = "ci"), n = unweighted(n())) %>%
#   mutate(summary = summary * 100, summary_low = summary_low * 100, summary_upp = summary_upp * 100)
# 
# # ggplot(data = out, aes(x = Q05_2_o_bin, y = summary, ymin = summary_low, ymax = summary_upp)) +
# #   geom_col(stat = "identity", position = "dodge") +
# #   geom_errorbar(position = position_dodge(width = 0.9), width = 0.1) +
# #   geom_text(aes(y = 0, label = n), position = position_dodge(width = 0.9), vjust = -1)
#       
# 
# p<-ggplot(data = out, aes(x = Q05_2_o_bin, y = summary)) +
#   geom_bar(stat = "identity", fill="skyblue3", color = "black", width = 0.3) +
#   geom_errorbar(alpha = 1, mapping = aes(Q05_2_o_bin, ymin = summary_low, ymax = summary_upp), inherit.aes = FALSE, size=.75, width=.1) +
#   ylim(0,100) +
#   theme_linedraw(base_size = 30) +
#   theme(legend.position="none") +
#   # labs(title = title,
#   #       x = xlab, y = ylab) +
#  #   theme(plot.title = element_text(hjust = 0.5)) +
#     theme(axis.text.x=element_text(angle=45,hjust=1))
# 
# #Temp add p
# plot(p)

```

<img src="www/cropped-logo-header.png" style="position:absolute;top:25px;right:0px;width:200px;height:75px" />

# Introduction
<b>Welcome to the State Of Organic Seed Producer Survey interactive report.</b>

State of Organic Seed is a project of Organic Seed Alliance that monitors the status of organic seed in the US and provides a roadmap for increasing the diversity, quality, and integrity of organic seed available.

In 2020, we conducted a national survey of certified organic crop growers to assess their attitudes and perceptions regarding organic seed, their current use of organic seed, and any obstacles that restrict organic seed sourcing. The survey also asked which crops and traits should be prioritized through organic plant breeding programs. Many additional topics were covered in this survey. We conducted a survey in 2010 and 2015 that asked many of the same questions, allowing us to measure our progress over the last five and ten years. 

This interactive report presents, in graphical form, the results of the latest organic farmer survey. It allow you to look at the responses from all farmers, or to view the responses from specific states. 

This survey was conducted in conjunction with the Organic Farming Research Foundation with funding by the USDA Organic Research and Education Initiative.

# Filter

:::: {.box}
By default, responses from all states are shown. To select a specific state or states, delete the "All" and select or enter the two-letter abreviations of the states you want to view data for.

```{r, Filter, echo=FALSE}
selectInput("state", "State:", choices=c("All",sort(unique(data$state))), selected="All", multiple=TRUE)

checkboxInput("Y2020", "Display 2020 Data", TRUE)
checkboxInput("Y2015", "Display 2015 Data", FALSE)
```
::::

$~$

# Appearance

:::: {.box}
Adjust the appearance of the graphs here

```{r, ShowN, echo=FALSE}
checkboxInput("show_n", "Display response numbers", FALSE)
```
::::

$~$


# Farm Demographics

$~$

## Farm Locations

```{r, Map, echo=FALSE}
    renderPlot({
      
      MapPlot (input = input)
      
    }, height = PLOTHEIGHT)

```

$~$

## Year Certified

```{r, Years, echo=FALSE}
    renderPlot({
    
       BinPlot (input = input, question = "YearsCertified_bin", title = "Years Certified", xlab = paste(paste(input$state,collapse = " "),"Years Certified"), ylab = "Percentage")
      
    }, height = PLOTHEIGHT)

```

$~$

## Vegetable Producer

```{r, VegProducer, echo=FALSE}
    renderPlot({
    
       BoxPlot (input = input, question = "GrowVegis", title = "Percentage of Respondents who Produce Vegetables", xlab = "", ylab = "Percentage")
      
    }, height = PLOTHEIGHT)

```

$~$

## Vegetable Acreage

```{r, VegAcre, echo=FALSE}
    renderPlot({
    
       BinPlot (input = input, question = "VegiAcreage", title = "Vegetable Acreage", xlab = paste(paste(input$state,collapse = " "),"Vegetable Acreage"), ylab = "Percentage")
      
    }, height = PLOTHEIGHT)

```

$~$

## Cover Crop Producer

```{r, CoverProducer, echo=FALSE}
    renderPlot({
    
       BoxPlot (input = input, question = "Q06", title = "Percentage of Respondents who Produce \nCover Crops or Green Pasture", xlab = "", ylab = "Percentage")
      
    }, height = PLOTHEIGHT)

```

$~$

## Cover Crop Acreage

```{r, CoverAcre, echo=FALSE}
    renderPlot({
    
       BinPlot (input = input, question = "Q06_2_o_bin", title = "Cover Crop Acreage", xlab = paste(paste(input$state,collapse = " "),"Cover Crop Acreage"), ylab = "Percentage")
      
    }, height = PLOTHEIGHT)

```

$~$

## Field Crop Producer

```{r, FieldProducer, echo=FALSE}
    renderPlot({
    
       BoxPlot (input = input, question = "Q07", title = "Percentage of Respondents who Produce Field Crops", xlab = "", ylab = "Percentage")
      
    }, height = PLOTHEIGHT)

```

$~$

## Field Crop Acreage

```{r, FieldAcre, echo=FALSE}
    renderPlot({
    
       BinPlot (input = input, question = "Q07_2_o_bin", title = "Field Crop Acreage", xlab = paste(paste(input$state,collapse = " "),"Field Crop Acreage"), ylab = "Percentage")
      
    }, height = PLOTHEIGHT)

```

$~$

# Organic Seed Usage

$~$

## Vegetable Seed Use

```{r, VegOGSeed, echo=FALSE}
    renderPlot({
    
      BoxPlot (input = input, question = "Q05aA", title = "Percent Vegetable Acreage \nPlanted To Organic Seed", xlab = paste(paste(input$state, collapse = " "),"Vegetable Acreage"), ylab = "Percentage")
      
    }, height = PLOTHEIGHT)

renderPlot({
    
      GradientMap (input = input, question = "Q05aA", title = "Percent Vegetable Acreage \nPlanted To Organic Seed", catlab =  "Percentage")
      
    }, height = PLOTHEIGHT)

```

$~$

## Cover Crop Seed Use

```{r, CoverOGSeed, echo=FALSE}
    renderPlot({
    
     BoxPlot (input = input, question = "Q06aA", title = "Percent Cover Crop Acreage \nPlanted To Organic Seed", xlab = paste(paste(input$state,collapse=" "),"Cover Crop Acreage"), ylab = "Percentage")
      
}, height = PLOTHEIGHT)

renderPlot({
    
      GradientMap (input = input, question = "Q06aA", title = "Percent Cover Crop Acreage \nPlanted To Organic Seed", catlab =  "Percentage")
      
    }, height = PLOTHEIGHT)

```

$~$

## Field Crop Seed Use

```{r, FieldOGSeed, echo=FALSE}
    renderPlot({
    
     BoxPlot (input = input, question = "Q07aA", title = "Percent Field Crop Acreage \nPlanted To Organic Seed", xlab = paste(paste(input$state,collapse=" "),"Field Crop Acreage"), ylab = "Percentage")
      
}, height = PLOTHEIGHT)

renderPlot({
    
      GradientMap (input = input, question = "Q06aA", title = "Percent Field Crop Acreage \nPlanted To Organic Seed", catlab =  "Percentage")
      
    }, height = PLOTHEIGHT)

```

$~$

# Organic Seed Production

$~$

## Producers Currently Saving Own Seed

```{r, SeedProduction, echo=FALSE}
    renderPlot({
    
     BoxPlot (input = input, question = "Q26B_yes", title = "Percentage of Producers \nGrowing Their Own Seed", xlab = paste(paste(input$state,collapse=" "),"Share of Producers"), ylab = "Percentage")
      
}, height = PLOTHEIGHT)

renderPlot({
    
      GradientMap (input = input, question = "Q26B_yes", title = "Percentage of Producers \nGrowing Their Own Seed", catlab =  "Percentage")
      
    }, height = PLOTHEIGHT)

```

$~$

## Interest in Growing Organic Seed

```{r, SeedInterest, echo=FALSE}
    renderPlot({
    
       BinPlot (input = input, question = "Q34", title = "Are you interested in producing organic seed for \ncommercial use at some point in the future?", xlab = paste(paste(input$state,collapse = " "),"Interest Level"), ylab = "Percentage")
      
    }, height = PLOTHEIGHT)

```

$~$

# Factors in Not Purchasing Organic Seed

$~$

## Lack of Seed Treatments

```{r, NoOGSeedTreat, echo=FALSE}
    renderPlot({
    
       BinPlot (input = input, question = "Q29A", title = "How much was lack of seed treatments \n(such as pelleting or priming) a factor in\n your decision NOT to purchase organic seed?", xlab = paste(paste(input$state,collapse = " "),"Factors"), ylab = "Percentage")
      
    }, height = PLOTHEIGHT)

```

$~$

## Buyer Requires Variety Not Available As Organic

```{r, NoOGSeedProcessor, echo=FALSE}
    renderPlot({
    
       BinPlot (input = input, question = "Q29B", title = "How much was processor (buyer) requiring \nor supplying varieties that are not available organically a factor in\n your decision NOT to purchase organic seed?", xlab = paste(paste(input$state,collapse = " "),"Factors"), ylab = "Percentage")
      
    }, height = PLOTHEIGHT)

```

$~$

## Insufficient Quantity of Seed

```{r, NoOGSeedQuant, echo=FALSE}
    renderPlot({
    
       BinPlot (input = input, question = "Q29C", title = "How much was an insufficient quantity of seed \na factor in your decision NOT to purchase organic seed?", xlab = paste(paste(input$state,collapse = " "),"Factors"), ylab = "Percentage")
      
    }, height = PLOTHEIGHT)

```

$~$

## Save Own Seed

```{r, NoOGSeedSave, echo=FALSE}
    renderPlot({
    
       BinPlot (input = input, question = "Q29D", title = "How much was saving your own seed \na factor in your decision NOT to purchase organic seed?", xlab = paste(paste(input$state,collapse = " "),"Factors"), ylab = "Percentage")
      
    }, height = PLOTHEIGHT)

```

$~$

## Distrust of organic seed quality

```{r, NoOGSeedQual, echo=FALSE}
    renderPlot({
    
       BinPlot (input = input, question = "Q29E", title = "How much was distrust of organic seed quality \na factor in your decision NOT to purchase organic seed?", xlab = paste(paste(input$state,collapse = " "),"Factors"), ylab = "Percentage")
      
    }, height = PLOTHEIGHT)

```
$~$

## Price

```{r, NoOGSeedPrice, echo=FALSE}
    renderPlot({
    
       BinPlot (input = input, question = "Q29F", title = "How much was price a factor in your decision \nNOT to purchase organic seed?", xlab = paste(paste(input$state,collapse = " "),"Factors"), ylab = "Percentage")
      
    }, height = PLOTHEIGHT)

```

$~$

## Variety not available as organic seed

```{r, NoOGSeedVar, echo=FALSE}
    renderPlot({
    
       BinPlot (input = input, question = "Q29G", title = "How much was the inavailability of specific \nvarieties in organic seed a factor in your \ndecision NOT to purchase organic seed?", xlab = paste(paste(input$state,collapse = " "),"Factors"), ylab = "Percentage")
      
    }, height = PLOTHEIGHT)

```

$~$

## Lack of desirable genetic traits

```{r, NoOGSeedTrait, echo=FALSE}
    renderPlot({
    
       BinPlot (input = input, question = "Q29H", title = "How much was the lack of desirable genetic traits \na factor in your decision NOT to purchase organic seed?", xlab = paste(paste(input$state,collapse = " "),"Factors"), ylab = "Percentage")
      
    }, height = PLOTHEIGHT)

```
